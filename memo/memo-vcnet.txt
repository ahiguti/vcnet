
--------------------------------------------------------------------------
TODO

- 現在時刻をサーバへ送信する
- SDへログ出力
- ethernet不達の状態から自動復帰
- vcnet_mcu: 120Hzキャプチャ、60Hzディスプレイで音声がおかしくなる
- vcnet_1g: フレーム間隔が不安定なのは何が原因か
  - ネット。ホスト側でvcnet以外のネットワークアクセスがあると遅延する。
  - lwipでtcp windowが65535 byteまでしか設定できないので吸い取るのが遅いと
    すぐに送信側がブロックする。linuxにするといいのか？
  - クライアントのRCVBUFは十分大きいので吸い取るスレッドの処理が遅いせいでは
    なく、tcp/ipスタックのせいではないか？
- vcnet_mcu: modifier keyが2回押されてる？
- vcnet_1g: たまにnetframe too large tag0=5 tag1=19ea42c
  - tagの値がおかしい
- vcnet_1g: deinterlacingのうまいやりかた
- capture: 1ms sleepするのではなく、vsyncかvideo captureのどちらかでwait
  するように。
- capture: msgに反映
- yuy2: yuv->rgb変換の係数を仕様通りに。
- glTexImage2DではなくPixel Buffer Objectで転送してみる
  - https://stackoverflow.com/questions/9863969/updating-a-texture-in-opengl-with-glteximage2d
- video_use_sample_reader
- absmouse 効かないことがある
  - recalc_draw_rect呼ばれないうちは効かない
- FIXME: vcnet_main.c
    value |= ((now & 32) != 0) ? 0x01 : 0x00;
    これ何？ ここは常に0x01を返すのが正しいのでは？
- video/audio無しのvcnetサーバをmcuだけで作れないか
  - bit bangingでmcu間broadcast通信してみる
- video/audio無しのvcnetサーバをmicroblazeで
- captureモードのときのmessage表示
- captureモードのビデオ表示をopenglでやる？
- 現状のYUVのdownsamplingの方法はあまりよくないのではないか。
  - YUV422のCbとCrは同じ位置(偶奇の中間)のサンプルとするべきでは？
    - 4:2:2 BT.601は左(偶数)のサンプルとしている？
      https://learn.microsoft.com/en-us/windows/win32/medfound/recommended-8-bit-yuv-formats-for-video-rendering
- 1gと10gのverilogソース差分解消
- vcnet_1g mbpのマウスおかしい
- artyz7-10 auto negoにしないとサーバがうごいてない？
- linux client: vcnet-1g 30i?
  - linuxがクライアントのときわずかに60i間に合わない
  - WSLではどうか？
  - vcnet-1gもudp実装するか？
- linux client: game controller
- FIXME: document: mtu 9000
- FIXME: document: RCVBUF
  - vcnet_10g linuxクライアント、RCVBUFを大きくしないとudpが落ちる
    - net.core.rmem_max = 33554432
    - net.core.wmem_max = 33554432
- オートメーション
- lwip: object ownership確認
- lwip: callbackの中でpcbをcloseしてよいのか？
- Lightning Digital AVアダプタ出力をvcnet_1gで読めない。10gは読める。
  - 720pだとどうか？ -> だめ
- 巻き添えでdevice0が起床する
  - devide0でもspi0でもなく、ha77が起床する
  - ha77のusb起床を無効化して回避
- 10g: HDMIパススルー出力へSPDIFで音声を
- 10g: 60hzディスプレイでウインドウ移動すると極端に遅延する
- wolをサーバからも送る
- samdでabsmouse有効にするとクラッシュする
  - joystickを無効にするとどうか？
- picoでmbedのほうもreport送信失敗時リトライできるか
- 10g: HDMIパススルー出力へSPDIFで音声を
- ウインドウ移動中に止まる
  - SetTimerで回避 -> 動作がおかしくなる
  - タイトルバーをクリックしたまま動かさないとイベント止まる
- GL版YUV411、左右端の色相がわずかに灰色になるのを避けられないか？
- 1g: dram経由せずにパススルー出力できないか
  - 試行: out側vtcのvsyncをin側に同期
  - 試行: in,out両方のvtc
- GUIを開いているあいだマウスを微量動かしてsuspend防止
- cstがpicoだと動かない？
- FIXME: document: ItsyBitsy M0 ビルドに Adafruit DotStar 必要
- PicoSDK版、Mouse.hの関数ををpublicにしないといけない
- PicoSDK版、Joystickのhatの計算おかしいのでpackageソース修正
- suspend/resume時におかしくなる。windowsクライアント。
- GUI表示中はマウスイベントを送ってsleepしないようにする
- imgui: GLESでないときは2.0コンテキストでもVAO使ってしまっているのでは？
- FIXME: document: DynamicHIDなど、必要なライブラリの整理。
- FIXME: document: arduinoライブラリの権利表示
- FIXME: document: macos absmousebutton=1が必要
- pro micro -> macos USE_ABSMOUSE有効のときマウスボタンが効かない
  - absmousebutton=1にすると効く
- pro micro -> macosで取りこぼしている？
- ios: wolのudpブロードキャストができない？
- SPI信号、かなりオーバーシュートしている。
- formatの番号 1がYUV411 に統一？
  - svr_flagsでは2がyuv411だがvideoフレームのフラグは上位から生やしたので
    bit逆順になっている。
- メモ: fpgaの前段にHDMI分配器をいれると切り替え時にvcnetサーバがクラッシュ
  している?(xvtcの問題?)
  - watchdogが発動しているもよう
  - クライアントはHDMIデバイス切り替え時に接続を切らないようにする。
- 壊れたデータを受信するとクラッシュしている？
- hid_intervalを大きくするとマウスを左右に振ったとき右にずれる
- メモ: USB alt mode displayport -> HDMI 変換アダプタ vcnet-1gでは動作せず。
  vcnet-10gでは問題ない。
- messageの右端がpitchまで伸ばされている
- zybo: yuv, opengl対応に更新
- yuv: tlastが出ていないが大丈夫なのか
- pi pico サスペンドから復帰時にクラッシュすることがある？
- PASS THROUGH MODEを試す
- spiで渡すデータの末尾のdeadbeefだけでなく頭にも入れる必要がある。
  ただし再現させにくい。
- SDLのaudioバッファを小さくすると壊れるので、音声遅延が大きい。
- udp10g: PCからのUDPパケットの末尾に無駄な0が入っている？
- udp10g: dropするときの原因を調べる
- capsが一度しか効かないのは何故？
- パスワード

--------------------------------------------------------------------------
DONE

- mbpのunderlineが効かないことがある。keymapの問題では。(done)
- capture: RALT+Yでフォーマットを変えられるように(done)
- yuy2: 読んでいるテクスチャオフセットがおかしい?(done)
  - loc_video_sizeに渡す値がおかしかった
- vcnet_1g: 接続が切れるとvideoが送られてこなくなる(done)
  - open_socket直後にsend_server_flagsを呼ぶ
- itsybitsyでabsmouseが使えない？(done)
  - capture_video有効のときcur_draw_rectがセットされていなかったため。
- captureでfullscreen(done)
- capture中fullscreenでguiを閉じると画面更新されなくなる(done)
  - hide/showして回避。ただしfocusが一度失われる。
- vcnet_1g yuv411 上でlagtest_modeを動かすと色化け(done)
  - #0000ffだけが色化けする
  - rgb24_to_yuv444_fullswing.v
- vcnet_1g audioおかしい？(done)
  - 一つ前のビルドでは問題なし
  - vcnetサーバがudpで送信する箇所のバグ
- absmouseを動的変更(done)
- video,audio送信を止められるように(done)
  - server_flagsのbit1, bit2が立っていればvideo, audioを送信しない
- vcnetサーバを複数指定できるようにする(done)
- WOL効いていない(done)
- 重複フレームカウント(done)
- クライアント側リフレッシュレートが低いとvsync有効時にフレームが
  溜まる?(done)
  - クライアント側50Hzなど
- vcnet_10g: パススルー出力(done)
- ir送信中はサーバのイベントループが止まるので一瞬マウスが固まる(done)
  - PLでウェイトを入れるようにして、CPUは止めないようにした
- YUVへの変換の計算方法 fullswing (done)
- vcnet1g: デフォルト1920x1080に。(done)
- pi picoはやはりusbがたまにおかしい？(done)
  - clipboardのペーストで化ける。
  - joystick: send_nowがときどきreport送信に失敗している
  - usb hidのreport送信失敗したらリトライするようにした
    - misc/rp2040_3_1_0_usb_fix.patch
- メモ: 165HzディスプレイとHDMI切替ソースを"複製する"にしている場合、その
  HDMI切替ソースが選択されているときにはVSYNCが60Hzになり、非選択のときは
  VSYNCが165Hzになる。windowsの場合。
- artyz7-20: HDMI出力が1920x1080のとき映らない(done)
  - 2018.2向けhdmi-inサンプルでは映る。これをベースに。
- axis_rgb2yuv411 ファイル名typo(done)
- gui: 詳細ステータス表示(done)
- artyz7: HDMI出力の解像度追従、GとB入れ替え[7:0]と[15:8](done)
- フルスクリーンにしたときにカーソルが出ない(done)
- corrupted data tag0=1 ...(done)
- 4号機のHDMI切り替え(done)
- vcnet-10g: クライアントのopengl版がおかしい(done)
  - 現在のバージョンではおかしくない
    - クライアントのバグ。draw_window_gl()の中glTexImage2Dの引数誤り。
- サーバから送信するフレームレートを制限できるようにする？(done)
  - 帯域足りていないときにスムースになる？
- FIXME: androidのassets内mplusフォントを丸呑みしているのをやめる(done)
- logmask 14 rawaudio.rawをfopenすると死ぬ
- spi2が効かない。断線？ -> はんだ不良(done)
- 信号線のプルダウン(done)
- mbpのcaps lockへのmapが効いていない？(done)
- gl: メッセージ文字列(done)
- gl: バイリニア補間(done)
- yuv: ピクセル偶奇が裏返ることがある(done)
- glのときabsmouseが効かないのはなぜ？(done)
  - get_cur_draw_rectが取れないため
- ubuntu22でvivadoが死ぬ (done)
  - XWaylandを使うと死ぬもよう。2018.2でも直ってないもよう。
  - https://support.xilinx.com/s/article/70442?language=ja
- joystickのremap(done)
- macで右下と右上のキーが効いていない。(done)
- macでIME(done)
- pasteがおかしい?(done)
- vcnet.cppからmcu i2c削除(done)
- artyz7版のspi対応(done)
- pi picoのspiがLSBFIRSTをサポートしないようなのでFPGA側をMSBFIRSTに変更(done)
- gamecontrollerを挿しているとkeyboardを取りこぼす(done)
- udp送信パケットを効率化(done)
- game controller(done)
- absmouseの位置(done)
  windowsなど送信側がclipしている場合(信号モードが画面解像度と一致しないとき)
  はabsmouseの座標計算は合わないが、これは避けようがない。
- mouseの遅延(done)
- udp10g: overlapped i/oでWSARecv(done)
- udp10g: オーディオ(done)
- udp10g: 一行抜けている(done)
- udp10g: 各種解像度(done)
- インタレースを切り替え(done)
- キーマップ設定(done)
  https://github.com/libsdl-org/SDL/issues/1059
- 音声が少し壊れている(done)
- i2sが48khzでないときがある(done)
- ブレッドボード無しでi2s(done)
- キーボード状態をリセットするコマンド(done)
- macに右altが無い(done)
- キーpress/releaseを正確に
  - キーリピート時に無駄に送信しない(done)
- 状態をLEDで(done)
- サーバ側をリセットすると1000fpsくらいで無駄ループが回る(done)
- ipアドレス設定(done)
- 一番下のライン、おかしなデータを送信している(done)
- windows client, ホスト側ディスプレイ60Hz, 60iのとき遅延がひどい
  - ホスト側のvsyncをoffにすると治る
  - TCP受信バッファにたまるのでは
- 2021.2でビルド(done)
- zynqからarduinoへのSPI通信(done)
- 「_」が打てないor化けることがある(done)

------------------------------------------
特殊キー割り当て


RLAT               マウス捕獲解除
button5            マウス捕獲解除
left               マウス捕獲
RALT + Enter       フルスクリーン切り替え
RALT + DEL         Ctrl+Alt+Del
RALT + I           インタレース切替
RALT + S           情報表示切替
button2 + 3 + 4    システムリセット

------------------------------------------
i2c_master.v

input VALID 実行開始。1クロックだけ1にすればよい。
output READY 準備完了フラグ
input DEVADDR[6:0] slaveの7bitアドレス
input REGADDR[7:0] 最初に書き込む1byte
input WDATA[31:0] 続けて書き込むデータ
input WBYTES[2:0] WDATAのバイト数
output RDATA[31:0] 書き込みのあとに読み出したデータ
input RBYTES[2:0] RDATAに読み出すバイト数

WDATAの前にREGADDRの1byteを書き込むので合計5byteまで書き込める
(書き込めていない?)

------------------------------------------
i2c_master.vをaxiから操作

レジスタ:
+0  +0x00:
  (read)
  READY[7:7]   i2cが準備完了したら1を返す
  ERR[2:0]     直前の操作で起きたエラーを返す
  (write)
  ADDR[6:0]    操作対象のi2c slaveの7bitアドレス
               これの書き込みをトリガーとしてi2c読み書きが実行される
+2  +0x08:
  WDATA[31:0]  (write)i2cで書き込むデータ
+4  +0x10:
  WBYTES[2:0]  (write)i2cで書き込むデータのバイト数
+6  +0x18:
  RDATA[31:0]  (read)i2cで読み出したデータ
+8  +0x20:
  RBYTES[2:0]  (write)i2cで読み出すデータのバイト数
+10 +0x28:
  LED[3:0]     (write)状態表示LED 兼 watchdog timerのハートビート
+12 +0x30:
  WATCHDOG     (write)watchdog timer作動時間(だいたい秒)
+14 +0x38:
  I2S_DATA     (read)i2s受信データを1サンプル読みだす
               読み出したデータはFIFOから削除される
+16 +0x40:
  GPIO         (write)HDMIスイッチ制御の赤外線センサ信号に使用
+18 +0x48:
  SVR_FLAGS[7:0] (write)サーバ設定。下2bitは画像フォーマット。


処理の流れ:
1. READYが1になるまで待つ。
2. WDATA, WBYTES, RBYTESに値をセットする。
3. ADDRに値をセットするとi2c読み書きが実行される。
4. READYが1になるまで待つ。
5. RDATAにi2cで読みだした値が入っているのでそれを読む。

------------------------------------------
FPGA IOピン

CK_SCL, CK_SDA
arduino shieldのscl, sda
マイコンへのi2c通信に使用

CK_IO0, CK_IO1
arduino shieldのioピン
旧i2c通信に使用していた(現在使用していない)

LED0, LED1, LED2, LED3
ボード上の緑LED
状態表示LEDとして使用

CK_IO2, CK_IO3, CK_IO4
arduino shieldのioピン
i2sのLR, DAT, BCLKとして使用

CK_IO13
HDMIスイッチ制御の赤外線センサ信号に使用


------------------------------------------

i2c読み出しコールバックで読み込むようにするとPCをsuspend/resumeすると
応答しなくなる。RSTを使うと復帰する。
割り込みコールバックを使わないとpicoで動かない。


------------------------------------------
謎モジュール

SCK 100MHzの1/8くらい 12.5MHz?
BCK SCKの1/4くらい 3.125MHz?

DATの最初のbitはLCKが変化した次のクロックサイクルなのか？ -> YES


------------------------------------------
HDMI信号

FullHD 1920*1080*60*24 = 2985984000 bits/sec (3G bps)
100MHzで32bit/cycleでおよそ3Gbps


------------------------------------------
pi picoでusb-i2s

I2S_DATA_PIN 28
I2S_CLOCK_PIN_BASE 26
26, 27, 28を使う?

26: BCLK
27: LR
28: DATA

片側あたり16bit


------------------------------------------
#1
9072:4416:633:497:628:497:627:497:627:498:627:497:628:496:628:497:628:1593:634:1594:627:1594:627:1595:628:1593:634:1593:628:1594:627:1595:633:491:628:1599:628:496:628:1595:627:497:627:497:628:497:628:496:628:496:628:496:629:1594:627:497:627:1595:628:1593:634:1593:628:1594:627:1595:627:39498:9023:2167:633
#2
9078:4388:656:469:655:469:655:469:656:470:654:470:654:470:655:464:661:1566:655:1566:656:1567:654:1567:660:1562:661:1565:656:1566:655:1567:655:470:654:1567:656:1565:661:1561:661:464:660:465:659:465:660:464:661:463:661:464:655:469:661:463:661:1562:660:1561:661:1566:656:1538:683:1567:654:39460:9051:2139:661
#3
9100:4383:661:463:661:464:666:458:666:458:661:459:666:459:665:459:665:1562:661:1560:661:1561:666:1556:665:1557:666:1555:666:1561:666:1556:665:460:665:459:666:458:667:458:666:1555:666:458:666:460:665:459:665:459:665:1557:666:1555:666:1555:667:459:665:1556:665:1556:667:1560:667:1555:666:39449:9056:2134:665
#4
9034:4410:634:486:638:486:638:487:637:487:639:485:639:486:639:485:639:1588:633:1589:633:1589:633:1588:634:1587:639:1584:638:1583:638:1589:634:490:634:1560:661:492:633:491:633:1589:633:491:634:490:634:491:633:491:634:490:634:1589:638:1561:661:486:639:1582:639:1583:638:1589:633:1589:633:39481:9023:2167:628
#5
9061:4406:638:492:638:488:637:488:640:485:641:485:640:485:640:486:640:1585:638:1586:635:1588:635:1589:635:1585:638:1591:633:1591:635:1588:635:491:635:1585:638:1591:638:488:634:1589:640:1584:640:493:632:493:638:487:638:488:635:490:635:1589:640:485:640:486:640:1585:638:1586:640:1584:640:39474:9044:2163:635

------------------------------------------
#          NUL SOH STX ETX EOT ENQ ACK BEL BS  HT  LF  VT  FF  CR  SO  SI
ch2usb@00: 000,000,000,000,000,000,000,000,000,02b,000,000,000,000,000,000
#          DLE DC1 DC2 DC3 DC4 NAK SYN ETB CAN EM  SUB ESC FS  GS  RS  US
ch2usb@10: 000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000
#          SP  !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
ch2usb@20: 02c,21e,21f,220,221,222,223,224,225,226,234,233,036,02d,037,038
#          0   1   2   3   4   5   6   7   8   9   ,   ;   <   =   >   ?
ch2usb@30: 027,01e,01f,020,021,022,023,024,025,026,034,033,236,22d,237,238
#          @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
ch2usb@40: 02f,204,205,206,207,208,209,20a,20b,20c,20d,20e,20f,210,211,212
#          P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
ch2usb@50: 213,214,215,216,217,218,219,21a,21b,21c,21d,030,089,032,02e,287
#          `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
ch2usb@60: 22f,004,005,006,007,008,009,00a,00b,00c,00d,00e,00f,010,011,012
#          p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   DEL
ch2usb@70: 013,014,015,016,017,018,019,01a,01b,01c,01d,230,289,232,22e,000

------------------------------------------
mellanox connectx-2の設定

Jumbo Packet を 9000 に

既定値
Interrupt Moderation (Enabled)
Rx Interrupt Moderation Profile (Moderate)
Rx Interrupt Moderation Type (Adaptive)
Receive Completion Method (Adaptive)
Number of Polls on Receive (10000)
Flow Control (Rx & Tx Enabled)
Receive Side Scaling (Enabled)
Receive Base Processor Number (0)
Receive load balancing Profile (closestProcessor)
Maximum Number of RSS Queues (8)
Virtual Machine Queues (Enabled)

------------------------------------------
udp -> axis -> i2c

送信UDPパケット
+0 len[7:0]
+1 type[7:0] 値が1のときマイコンへのi2c、5のときサーバ内i2c
+2 i2cの7bitデバイスアドレス
+3 i2cデータ0byte目(レジスタ番号)
+4 i2cデータ1byte目(書き込む値)

8byte未満なので1wordのaxisに変換


------------------------------------------

txoffset==5 +2以降がpayloadの可能性
rxlen_copyが8未満のときはこのワードが終端
txd <= { rxd_copy[63:16], 16^h0 };
txlen <= rxlen_copy;
rxlen_copyが2より大きいときはpayloadを持つ
udp_len_prev <= (rxlen_copy > 2) ? (rxlen_copy - 2) : 0;
  // これは0以上6以下
udp_d_prev <= (rxlen_copy > 2) ? rxd_copy[63:16] : 0;
  // 上位48bitをudp_d_prevに記録

txoffset==6 すべてがpayloadの可能性
udp_len <= (rxlen
udp_d <= { rxd_copy[15:0], udp_d_prev[47:0] };
  // 前のサイクルの48bitと今のサイクルの16bit


------------------------------------------
PMODへi2cを出すときのピンアサイン

Zybo
PMODのピン番号
   06 05 04 03 02 01
   12 11 10 09 08 07

set_property PACKAGE_PIN J15 [get_ports I2C_SCL_0]     # PMOD JE Pin 3
set_property PACKAGE_PIN H15 [get_ports I2C_SDA_0]     # PMOD JE Pin 4
set_property IOSTANDARD LVCMOS33 [get_ports I2C_SCL_0]
set_property IOSTANDARD LVCMOS33 [get_ports I2C_SDA_0]

AESKU040のPMODコネクタ
端から順に、PMOD3, PMOD4, PMOD1, PMOD2 の順。
PMOD3に差す。Bank 46 VCCO=1.8V
PMOD3_0 F18
PMOD3_1 F19
PMOD3_2 G17  これをI2C_SCLに
PMOD3_3 F17  これをI2C_SDAに

// 0: stat送信要求
// 1: マイコンへのi2cコマンド(USBマウス等)
// 2: サーバのリセット要求
// 3: irコマンド
// 4: サーバフラグの書き換え
// 5: サーバ内i2cコマンド(adv7611等)

UDPパケット 6byteの大きさ
+0 payloadの長さ(4), +1 reqtype(マイコンへのiicは0x01),
+2 iicの7bitアドレス
+3 usb操作の種類(moveなら1, buttonなら2, wheelなら3, keyboard ??
+4 データ0
+5 データ1

0x04, 0x01, (iicアドレス), devaddr, data0, data1


------------------------------------------
interlacedのeven/oddフレームの区別

VSがassertされると同時にHSもassertされるのがevenまたはprogressive、
VSがassertされるのがHSがassertされるのとずれているのがodd?
ADV7611-UG-180.pdfのpp.132

------------------------------------------

https://akizukidenshi.com/catalog/g/gP-12171/
・長辺外形：47.0mm
・短辺外形：36.0mm
・取付穴径：3.2mm
・取付穴間隔長辺：41.0mm
・取付穴間隔短辺：30.0mm

長辺 0.5mm * 8 外形 10穴
短辺 0.5mm * 6 外形 8穴


------------------------------------------
hdmi switch #2

####INPUT1
9027,4545,519,615,521,639,521,614,520,614,523,590,540,593,543,594,538,1725,518,1724,493,1748,519,1701,542,1720,520,1698,540,1726,493,1748,516,618,515,1728,490,644,513,1730,513,621,515,619,515,618,516,620,514,620,490,645,512,1729,514,622,514,1727,515,1727,513,1727,516,1725,538,1705,513
v=1
cnt=67
9003,4569,518,616,517,591,572,588,519,617,517,616,521,593,539,619,514,1727,515,1725,518,1725,515,1726,515,1728,513,1727,516,1727,512,1728,514,621,489,1752,515,621,488,1752,490,646,511,621,512,622,514,623,514,618,512,623,516,1729,513,621,513,1727,513,1727,516,1728,510,1731,489,1751,513
v=1
cnt=67
8999,4567,521,614,521,612,519,590,547,614,520,614,519,616,521,596,564,1670,544,1697,546,1721,519,1721,519,1698,546,1719,518,1701,567,1673,543,592,568,1695,516,617,520,1721,522,591,540,616,520,600,534,615,519,617,514,619,492,1725,543,617,490,1748,519,1724,518,1724,524,1716,516,1725,517
v=1
cnt=67
9243,4335,654,510,552,554,581,554,582,556,578,583,552,583,675,460,657,1585,653,1589,530,1714,625,1618,528,1714,577,1666,527,1717,526,1717,529,606,583,1659,560,575,555,1662,557,606,555,580,554,580,553,583,579,557,526,609,551,1663,580,557,553,1689,553,1689,554,1690,551,1692,551,1692,576,39877,9037,2273,572
v=1
cnt=71
9121,4462,583,554,580,555,582,583,703,431,730,380,607,529,558,578,580,1662,559,1712,603,1641,530,1713,631,1613,528,1714,608,1636,561,1683,533,603,555,1689,560,575,586,1658,584,552,586,549,586,550,584,553,586,548,583,553,557,1658,609,555,554,1663,582,1661,582,1660,581,1663,581,1664,603,39854,9069,2244,579
v=1
cnt=71
9052,4532,560,604,555,580,581,555,560,577,558,576,562,574,589,547,563,1681,584,1660,562,1681,563,1681,566,1678,564,1680,587,1630,615,1628,616,546,587,1630,617,547,587,1629,615,548,588,548,556,581,559,577,554,558,579,554,582,1660,583,554,581,1660,607,1637,580,1662,582,1663,581,1663,580,39876,9065,2246,579
v=1
cnt=71


####INPUT2
8944,4595,489,674,460,646,490,700,435,674,484,623,487,673,461,646,512,1730,489,1751,489,1752,488,1753,531,1712,538,1704,540,1703,488,1776,440,694,463,1807,434,1752,515,1729,461,724,437,648,488,670,464,696,439,645,516,643,463,672,488,644,465,1779,435,1777,489,1749,518,1725,512,1730,514
v=1
cnt=67
8989,4550,543,591,516,616,510,653,460,646,490,643,490,674,461,645,489,1751,496,1728,560,1701,518,1725,496,1771,462,1750,514,1782,434,1752,516,597,536,1728,491,1776,438,1829,435,698,459,651,462,673,460,658,477,670,490,621,490,647,488,643,539,1701,516,1724,538,1704,540,1701,519,1728,509
v=1
cnt=67
8992,4602,464,669,467,651,507,618,516,618,490,673,437,724,435,649,512,1727,515,1728,514,1778,432,1780,486,1755,468,1723,514,1755,508,1728,490,727,461,1701,489,1750,489,1753,487,675,490,593,514,646,514,616,490,649,514,616,518,619,538,595,514,1754,489,1725,489,1754,463,1776,535,1705,541
v=1
cnt=67
9180,4388,581,557,781,350,812,322,583,554,579,556,730,407,579,553,661,1610,553,1664,578,1663,578,1663,580,1665,674,1568,577,1688,679,1563,651,484,554,1687,729,1513,554,1689,631,504,551,583,579,556,529,606,595,539,602,534,578,556,526,609,576,1665,527,1715,581,1661,554,1688,557,1686,555,39856,9061,2240,581
v=1
cnt=71
9094,4476,588,549,587,546,610,524,585,552,582,551,609,525,612,524,585,1656,585,1658,583,1658,582,1659,581,1661,579,1663,578,1665,579,1663,579,556,578,1662,579,1665,578,1670,570,557,577,559,550,584,551,583,577,559,575,559,551,584,551,584,573,1668,552,1692,547,1693,549,1693,549,1696,570,39867,9025,2277,544
v=1
cnt=71
9062,4506,581,554,557,580,579,552,609,526,581,555,557,579,580,551,585,1658,607,1636,579,1662,555,1687,581,1659,579,1664,556,1685,578,1664,580,555,581,1662,580,1660,578,1666,579,554,555,581,553,581,579,555,578,555,553,583,553,582,577,557,553,1690,551,1690,551,1690,553,1691,550,1690,551,39885,9027,2274,548
v=1
cnt=71

####INPUT3
9060,4506,581,503,630,496,638,547,587,557,579,555,579,163,1167,361,580,1687,814,1427,666,1575,629,1612,528,1714,553,1688,593,1647,626,1615,555,579,528,608,524,610,577,557,554,1688,528,606,529,605,552,582,579,556,581,1633,580,1661,580,1660,555,581,576,1664,553,1688,577,1664,577,1665,575
v=1
cnt=67
9269,4299,582,554,582,552,684,453,705,456,628,481,684,450,579,558,577,1690,579,1661,553,1689,680,1562,553,1688,575,1666,648,1594,555,1686,550,585,624,511,628,506,627,508,628,1614,600,534,579,556,529,606,527,607,537,1704,579,1663,550,1692,582,552,582,1660,529,1712,583,1658,559,1684,558
v=1
cnt=67
9060,4501,657,508,605,529,629,477,679,456,581,554,581,585,550,579,529,1711,529,1711,604,1638,559,1682,552,1689,530,1710,560,1681,586,1658,581,551,583,552,557,578,583,549,585,1657,583,551,583,551,583,551,585,548,586,1627,585,1658,580,1660,607,555,555,1660,579,1661,576,1665,580,1662,604
v=1
cnt=67
9064,4506,583,554,580,555,581,556,802,330,778,357,829,308,816,317,804,1440,652,1591,756,1488,655,1586,701,1543,577,1688,554,1689,554,1688,650,485,554,581,702,433,657,478,633,1609,658,477,603,538,618,511,554,581,554,1688,600,1641,575,1668,529,606,547,1694,530,1713,529,1714,576,1665,597,39813,9037,2268,557
v=1
cnt=71
9211,4365,580,582,554,581,650,485,630,505,530,606,626,508,605,531,529,1712,574,1669,527,1715,554,1689,528,1714,556,1686,530,1713,580,1635,581,581,529,606,552,583,553,582,552,1662,602,561,552,559,574,560,577,558,576,1665,576,1665,577,1666,550,585,575,1667,576,1667,550,1692,561,1681,574,39873,9030,2274,546
v=1
cnt=71
9069,160,187,4163,579,555,582,551,583,554,582,553,581,555,579,555,581,555,576,112,162,1393,579,1689,553,1689,553,1689,553,1689,553,1689,752,1490,675,1567,554,581,652,482,554,581,697,438,655,1585,575,560,553,583,654,480,530,605,530,1711,625,1618,630,1611,595,541,600,1641,528,1714,577,1665,552,1689,556
v=1
cnt=71



####INPUT4
9080,4479,557,587,572,581,580,526,557,579,553,615,518,609,527,607,577,1662,556,1685,578,1662,579,1662,577,1662,531,1710,554,1686,555,1686,581,553,533,1707,558,577,559,575,561,1679,560,575,559,574,559,575,587,547,587,547,584,1633,607,1630,609,552,581,1632,609,1631,581,1659,579,1662,578
v=1
cnt=67
9053,4507,580,493,638,391,745,555,579,433,701,526,607,556,580,525,607,1665,587,1656,575,1662,579,1664,576,1689,553,1664,577,1688,550,1689,553,555,834,1432,828,274,809,334,826,1438,666,469,768,367,552,582,552,581,737,398,730,1510,675,1565,723,411,672,1568,649,1593,673,1567,528,1713,606
v=1
cnt=67
9049,4509,578,554,579,557,881,216,871,266,838,356,751,383,699,434,730,1510,528,1713,552,1688,601,1640,575,1665,601,1639,552,1688,526,1715,577,558,526,1715,552,581,551,583,555,1660,580,579,554,580,551,583,576,532,552,581,552,1689,551,1689,577,557,575,1665,574,1666,551,1691,572,1669,572
v=1
cnt=67
9037,4561,527,586,572,564,549,585,551,584,550,586,549,585,551,585,549,1535,706,1606,636,1498,744,1485,757,1689,575,1632,610,1397,822,1307,936,584,551,1126,258,330,550,561,551,585,575,527,639,523,528,392,765,249,4295,262,109,1322,753,1485,528,607,570,1650,548,1715,527,1692,573,1669,548,39875,9035,2273,571
v=1
cnt=71
9061,557,201,3750,580,555,578,554,582,554,580,522,612,553,581,554,582,488,646,1662,580,1662,580,1664,577,1663,577,1664,578,1663,580,1688,551,1665,578,313,820,297,106,1286,554,205,929,152,1248,1422,811,324,554,582,699,435,554,580,621,515,650,1590,571,1670,597,541,573,1666,526,1715,552,1664,554,1686,582
v=1
cnt=71
8994,4576,542,595,463,696,459,648,593,543,516,621,538,594,464,699,459,1758,484,1752,520,1749,461,1752,514,1730,490,1750,518,1779,458,1730,490,696,411,1803,461,675,462,618,569,1753,461,620,512,622,543,592,518,621,486,699,434,1755,516,1750,462,645,515,1780,460,1728,541,1699,530,1712,541,39938,8916,2410,460
v=1
cnt=71


####INPUT5
9018,4545,543,590,544,614,520,614,520,593,543,614,516,617,517,593,546,1720,518,1701,543,1720,518,1700,544,1719,544,1699,492,1728,541,1720,519,593,544,1697,541,1725,515,619,514,1727,492,1749,492,643,491,643,516,595,540,617,518,619,513,1704,540,617,516,620,513,1728,515,1702,539,1727,513
v=1
cnt=67
9040,4542,519,588,546,589,546,591,568,569,548,606,520,593,540,591,540,1726,519,1698,543,1720,520,1701,541,1697,543,1697,546,1718,520,1698,544,614,519,1722,495,1747,516,616,517,1702,567,1673,541,593,543,615,518,615,518,616,519,593,543,1721,517,617,492,641,519,1722,518,1724,514,1728,514
v=1
cnt=67
9018,4546,544,588,543,593,542,593,542,615,518,618,514,619,514,620,517,1724,515,1726,516,1726,489,1751,516,1728,510,1728,516,1733,509,1727,513,622,513,1729,511,1729,489,644,515,1728,512,1729,514,622,513,621,488,644,517,621,487,645,514,1728,515,620,550,585,514,1727,514,1727,515,1725,514
v=1
cnt=67

------------------------------------------
game controller

0x20, 0x21
  buttonCount 32 (2回に分ける)
        void setButton(uint8_t button, uint8_t value);

0x22
  hat 2 (0以上8以下の値、押していないとき8)
        void setHatSwitch(int8_t hatSwitch, int16_t value);

0x24, 0x25, 0x26, 0x27, 0x28, 0x29
AXIS 6 x y z rx ry rz (-32767以上32767以下)
        void setXAxis(int16_t value);
        void setRxAxis(int16_t value);

0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f(予約)
Rudder, Throttle, Accelerator, Brake, Steering (-32768以上32767以下)
        void setRudder(int16_t value);
        void setThrottle(int16_t value);
        void setAccelerator(int16_t value);
        void setBrake(int16_t value);
        void setSteering(int16_t value);

0x20でsend report

SDL_INIT_JOYSTICK

void SDL_JoystickUpdate(void);

int SDL_JoystickNumAxes(SDL_Joystick *joystick);
int SDL_JoystickNumHats(SDL_Joystick *joystick);
int SDL_JoystickNumButtons(SDL_Joystick *joystick);

Sint16 SDL_JoystickGetAxis(SDL_Joystick *joystick, int axis);
Uint8 SDL_JoystickGetHat(SDL_Joystick *joystick, int hat);
Uint8 SDL_JoystickGetButton(SDL_Joystick *joystick, int button);

------------------------------------------
MCU: pi picoでSPI通信, TinyUSB

10MHzのSPI, 32バイト転送に100MHzが5500サイクル。
TinyUSB keyboard、レポートに3ms以上間隔を開けないとホストが取りこぼす。

pro micro 8MHz
2MHzのSPI 32バイト転送に100MHzが18288サイクル
4MHzのSPI 32バイト転送に100MHzが11951サイクル

------------------------------------------
SPI送信データ

+0  (1) mcu id (最上位bitは使用しない)
+1  (1) mouse seq (mouse moveの値が更新されたときincrement)
+2  (1) mouse delta x
+3  (1) mouse delta y
+4  (1) mouse wheel x
+5  (1) mouse wheel y
+6  (2) absmouse x
+8  (2) absmouse y
+10 (1) mouse/absmouse button
+11 (1) keymod
+12 (6) keycode
+18 (1) gc button
+19 (1) gc button 4bit, hat 4bit
+20 (12) analog axes
+32 (-) magic number

ボタン4byte
アナログ11軸22byte
hat2個1byte
計27byte
ボタン11個2byte, 6軸12byte, hat1byte
15
アナログ12bitにすると6軸9byte, 12byte

------------------------------------------

https://ez.analog.com/video/f/q-a/10895/component-mode-and-graphics-mode-in-adv7611

Component mode normally refers to YCbCr (or YUV) color space with syncs on the green channel while Graphics mode normally refers to RGB color space with separate syncs.  For HDMI the mode is determined by the input color space defined in the AVI Infoframe of the incoming video stream with the syncs already embedded in the stream.

For the ADV7611 both stream  are processed by the Component Processor since the only real difference is the color space.

You can control saturation, brightness, hue and contrast easier in YUV color space.

既定値:
98 00 08  2'b0, VID_STD[5:0]
98 01 06  1'b0, V_FREQ[2:0], PRIM_MODE[3:0]
98 02 F0  INP_COLOR_SPACE[3:0] ALT_GAMMA, OP_656_RANGE, RGB_OUT, ALT_DATA_SAT
98 03 00  OP_FORMAT_SEL[7:0]
98 04 62  OP_CH_SEL[2:0], 2'b0, XTAL_FREQ_SEL[1:0], 2'b0
98 05 2C  3'b0, F_OUT_SEL, DATA_BLANK_EN AVCODE_INSERT_EN, REPL_AV_CODE, OP_SWAP_CB_CR
98 06 A0  VS_OUT_SEL, 3'b0, INV_F_POL, IN_VS_POL, IN_HS_POL, INV_LLC_POL

1080p_qs3.txt:
98 01 06 (HDMI Graphics)
98 02 F2 RGB_OUT これを立てるとCSC出力がRGBになる？
VID_STD(=8)とPRIM_MODE(=6)は既定のまま
  HDMI Graphics(RGB?) 640x480@60

PRIM_MODEを06, VID_STDを''h19にすると1920x1200@60
  98 00 19 98 01 06
PRIM_MODEを06, VID_STDを''h18にすると1680x1050@60
  98 00 18 98 01 06
PRIM_MODEを06, VID_STDを''h05にすると1280x1024@60
  98 00 05 98 01 06
PRIM_MODEを06, VID_STDを''h0cにすると1024x768@60
  98 00 0c 98 01 06
PRIM_MODEを06, VID_STDを''h01にすると800x600@60
  98 00 01 98 01 06
PRIM_MODEを06, VID_STDを''h08にすると640x480@60
  98 00 08 98 01 06

PRIM_MODEを05, VID_STDを'h14, 'h16, 'h1e, 'h1fのどれかにすると1080p?
  98 00 14 98 01 05

------------------------------------------
artyz7版ピンアサイン

右側の下から
CK_IO0と1が旧I2CのSCL, SDAなので変更してok
CK_IO2, 3, 4がI2SのLR, DAT, BCLK
CK_IO13がIR_OUT
GND, AREF
SDA, SCLがI2CのSDA, SCLに使用
CK_IOの0, 1, 5, 6, 7, 8, 9, 10, 11, 12が利用可能
A0からA5も利用可能

------------------------------------------
全角/半角

javascript
(半角から全角) 243 up, 229 down
(全角から半角) 244 up, 229 down
windows

------------------------------------------
IR38060 PMBus

device address:
  0.95v: 0x42 
  1.0v: 0x43
  1.2v: 0x44
  1.2v GTH: 0x45
  1.8v GTH: 0x46
  1.8v: 0x47


0x01 OPERATION 既定値 0x80
  0x00を書き込むと Immediate Off
  0x40を書き込むと Soft Off
  0x80を書き込むと On

https://docs.xilinx.com/v/u/ja-JP/ds892-kintex-ultrascale-data-sheet

電源投入/切断シーケンス

VCCINT: 内部電源 0.95v
VCCINT_IO IOバンクの内部電源 0.95v?
VCCBRAM: ブロックRAM 0.95v
VCCO: HRとHP I/O 電圧? 1.14-3.40, 0.95-1.89 1.8v?
VCCAUX: 補助電源? 1.8v?
VCCAUX_IO: 補助I/O 1.8v
VMGTAVCC: トランシーバのアナログ電源 1.0v?
VMGTAVTT: トランスミッタとレシーバのアナログ電源 1.2v?
VMGTVCCAUX トランシーバのアナログクワッドQPLL電源電圧 1.8v?
VMGTAVTTRCAL トランシーバからむの抵抗キャリブレーション回路 1.2v?

推奨: VCCINT/VCCINT_IO, VCCBRAM, VCCAUX/VCCAUX_IO, VCCOの順
(電流が最小になるように、またIOがトライステートになるために)
-> 0.95v, 1.8vの順

VCCADCとVREFは随時立ち上げ可。

推奨: VCCINT, VMGTAVCC, VMGTAVTTの順、またはVMGTAVCC, VCCINT, VMGTAVTTの順
(トランシーバの電流が最小になるように)
-> 0.95v, 1.0v, 1.2vの順、または1.0v, 0.95v, 1.2vの順

device address若い順でよさそう。
0x42から0x47まで。


------------------------------------------
冷却ファン

vcnet_10g走らせ、PMOD抜いた状態。
冷却ファンなし: 50.8
冷却ファンあり: 39.5

箱open 全台sleep: 43.4

------------------------------------------
joystick

スーファミ
ボタン: B(下),Y(左),SEL,STA,A(右),X(上),L,R

XINPUT
ボタン: A(下),B(右),X(左),Y(上),L,R,SEL,STA,LS,RS

すべてのコントロール値を16bit値へ変換する。
ボタン12, hat4, axis12,axisu6
axisは各軸の正負それぞれを1個の値に
axisuは各軸を

------------------------------------------


LCD
138.50MHz
1920 1080
160 31
48 3
32 5
510 287
0 0

------------------------------------------

nvidia設定でRGB Fullにできる
ディスプレイ -> 

------------------------------------------
yuv422

2pixel 4byte U0, Y0, V0, Y1 の順

c = Y'- 16
d = U - 128
e = V - 128
R = (298*c + 409*e + 128) >> 8
G = (298*c - 100*d - 208*e + 128) >> 8
B = (298*c + 516d + 128) >> 8

------------------------------------------

|Y'|   |  66 129  25 ||R|
|Cb| = | -38 -74 112 ||G|
|Cr|   | 112 -94 -18 ||B|

Y't = (Y' + 128) >> 8
Cbt = (Cb + 128) >> 8
Crt = (Cr + 128) >> 8

Y'u = Y't + 16
Cbu = Cbi + 128
Cru = Crt + 128
これを[0..255]にclamp

------------------------------------------
(0,1)の座標がv_coordに入っている
v_coord * v_view_sizeが(0,1920)(0,1080)の座標
floorで整数部分をとれる


------------------------------------------
bilinear

vec2 video_size;
vec2 video_pos = coord * video_size; // ビデオテクスチャのピクセル単位の座標
floor(video_pos-0.5)とfloor(video_pos+0.5)の4点のテクスチャを引く
テクスチャを引く:
  texture2D(texture, (p + 0.5) * video_size_inv);
vec2 a = (video_pos-0.5) - floor(video_pos-0.5);
c00, c01, c10, c11とすると、以下でbilinear補間。
c0 = mix(c01, c00, a.x);
c1 = mix(c11, c10, a.x);
c = mix(c1, c0, a.y);

------------------------------------------
ESP32 SPI
VSPI MOSI: GPIO23, MISO GPIO 19, SCLK GPIO 18, CS GPIO 5
CK_IO0 SCLK #0 - ESP32 GPIO 18
CK_IO1 MISO #0 - ESP32 GPIO 19

------------------------------------------
Y = 0.299R + 0.587G + 0.114B
Cb = -0.168736R - 0.331264G + 0.5B
Cr = 0.5R - 0.418688G - 0.081312B
R = 1Y +0Cb +1.402Cr
G = 1Y -0.344136Cb -0.714136Cr
B = 1Y + 1.772Cb +0Cr

------------------------------------------
Y = 0.2126 + 0.7152G + 0.0722B       (0 .. 1)
Cb = - 0.114572R - 0.385428G + 0.5B (-0.5 .. 0.5)
Cr = 0.5R - 0.454153G - 0.045847B (-0.5 .. 0.5)
R = 1Y + 0Cb + 1.5748Cr
G = 1Y - 0.187324Cb - 0.468124Cr
B = 1Y + 18556Cb - 0Cr

257(=65535/255)倍
y0 = 54.6382r + 183.8064g + 18.5554b
cb = - 29.445004r - 99.054996g + 128.5b
cr = 128.5r - 116.023421g - 11.782679b
整数に丸め
(55, 184, 19)     (0 .. 65535)
(-29, -99, 129)   (-32768 .. 32767)
(129, -116, -12)  (-32768 .. 32767)
257で割って
(0.2140077821, .7159533073, .0739299610)
(-.1128404669, -.3852140077, .5019455252)
(.5019455252, -.4513618677, -.0466926070)
逆行列
0.99003705636608        2.4518018959E-4         1.5701943578505
0.99867965308817        -0.19068878649899       -0.46866167238607
0.98899504097659        1.8459606233309         -0.006681156506554

y0cbcrを16bit整数で計算、cbとcrは+32768を加える。
16bit値を256で割る。これが(0 .. 255)の値になる。
シェーダには0..1の値が渡る。cbとcrは0.5を減ずる。
上の逆行列でRGB値を計算。(0..1)の値になる。

------------------------------------------
メモ: android-project
- SDL2-2.26.3.tar.gzを~/buildの下に展開
- SDL2_ttf-2.20.2.tar.gzを~/buildの下に展開
- SDL2-2.26.3/android-projectディレクトリをvcnet_clientの下にコピー
- android-project/app/jniの下で ln -s ~/build/SDL2-2.26.3 SDL2
- android-project/app/jniの下で ln -s ~/build/SDL2_ttf-2.20.2 SDL2_ttf
- app/jni/src/Android.mkのLOCAL_SRC_FILESを書き換える
- app/jni/src/Android.mkのLOCAL_SHARED_LIBRARIESにSDL2_ttfを追加
- app/jni/src/Application.mkに APP_STL := c++_shared を追加
- SDLActivity.java: getLibrariesにSDL2_ttf
- AndroidManifest.xml
    <uses-permission android:name="android.permission.INTERNET" />
- source android_env.sh
- ./gradlew installDebug


------------------------------------------
IPコア差分
            サンプル      vcnet
rgb2dvi     1.3(Rev.3)    1.4(Rev.8)
axi_dynclk  1.0(Rev.3)    1.1(Rev.16)
dvi2rgb     1.7(Rev.3)    2.0(Rev.5)

------------------------------------------
送信と表示を独立させるには

ビデオフレームの最後のラインを送信した後の処理
if (offset_line == 0) {
  cur_read_frame ^= 1u;
  vcnet_video_set_video_frame(cur_read_frame ^ 1u, cur_read_frame);
    // 最初の引数がキャプチャ書込みするアドレス、次の引数が出力するアドレス。
  video_frame_data = vcnet_video_get_frame_data(cur_read_frame, &v, &h);
  waiting_flip = 1;
}
vcnet_video_set_video_frame呼び出しでは、キャプチャ書込みアドレスとして
ネットワーク送信が完了した領域を指定している。waiting_flip=1にすると、
キャプチャ書込みアドレスが指定した領域に切り替わるまで待ち、切り替わった
ことを確認すると、書き込んでいないほうの領域のネットワーク送信を開始する。

送信領域と表示領域を別々に指定するには
cur_read_frame: 送信中のフレーム。ただしwaiting_flip=1のときは送信待機。
cur_disp_frame: 表示するように指定したフレーム。切り替わるまでは1フレーム
  未満の時間がかかる。
cur_video_frame: キャプチャ書き込みに指定したフレーム。切り替わるまでは
  1フレーム未満の時間がかかる。
キャプチャ書き込みが現在どのアドレスで起きているかは43c30000
(peek_dma_addr.vが取得しているアドレス)を読めばわかる。

以下誤り。
# dispとvideoを2枚の領域を交互に指定しているのは、走査タイミングによっては
# おかしな表示になるのでは？ただしくは、
# 1. video領域切替を指定する
# 2. video領域が切り替わる(dmaアドレスを見て確認する)まで待つ
# 3. disp領域を、先にvideo領域であった場所へ切替指定する
# のようにする必要がある。video領域切替の際には、disp指定とdisp dmaのどちら
# でもない領域を指定する必要があるので、3枚分のバッファを必要とする。
# 送信と表示を独立させるためには、送信領域を含め4枚分のバッファが必要。
以上誤り。

dispとvideoのvsyncの位相がほぼ一致していたとすると、vsyncの半周ずれた
あたりでdispとvideoの領域を別々のものに指定すれば、必ず別々の領域でdma
転送がおきる。
dispとvideoのvsyncの位相が半周ずれていたとすると、videoのvsyncのあたりで
dispの領域を(dispと同じものに)切り替え、dispのvsyncのあたりでvideoの領域を
(videoと同じものに)きりかえればよい。

videoのdmaが1になったらなるべく早くvideoに0、dispに1を指定する。
そうすればvideoのdmaアドレスになるべくすぐうしろをdispのdmaが追いかける
ようになる。video dmaに対するdisp dmaの遅れは、1周期+alpha、alphaは1周期
よりもじゅうぶん短いので、2枚のバッファリングで追いつくことはない。

送信領域と表示領域を別々に指定するには、送信が60hzに追いつかないことがある
なら3枚のバッファが必要。
cur_video_frame = 0;
cur_disp_frame = 1;
cur_read_frame = 1;
vcnet_set_video_frame(cur_vide_frame, cur_disp_frame);
while (true) {
  video_dma_frame = (現在のvideo読み込みdmaアドレスのいる領域)
  if (video_dma_frame == cur_video_frame) {
    // 指定された領域へのdma書き込みが始まった
    cur_disp_frame = cur_video_frame;
      // dispはvideoのdmaアドレスのなるべく直後を追いかける
    if (waiting_flip) {
      cur_read_frame = cur_video_frame;
      waiting_flip = 0;
    }
    cur_video_frame = (readでもdispでもない値)
  }
}

1,1,3,2,6,4,12,8
1,3,2,6,4,12,8,9

------------------------------------------
adv7511

ADV7511のD[23:8]しかFPGAボードにつながっていない。
Page 24 of 58, Table 7
YCbCr 4:2:2 Formats Input Data Mappng:
R0x48[4:3] = 01 (right justified)
これの Style 1 にすればよい。
(並びが変わるだけでStyle 2 or 3 でもよい。)
Style は R0x16[3:2]にセットする。
R0x48[4:3] = 01, InputID(R0x15[3:0]) = 1 or 2
InputID = 1: separate syncs.
InputID = 2: embedded syncs.
R0x16[5:4]にdata bit width

R0x15
  [3:0] Input ID, 1でいい？
  8'h01
R0x16
  [7] Output Format, 0: 4:4:4, 1: 4:2:2 (1でよい)
  [5:4] Color Depth, 11 = 8bit
  [3:2] Input Style, 01 = style 2, 10 = style 1, 11 = style 3 (style2?)
  [1] DDR Input Edge, (関係なし)
  10110100?
  8'hb4

メモ:
ha-fpga-misc/zed_adv7511 にYUV422表示できているらしいadv7511設定を
保存しておいた。

--------
test_mul_fixed_ku115
test_mul:
  multiply_fixed使用:
    CLB LUTs 48 CLB Registers 46 CARRY8 8 CLB 10 LUT as Logic 48 LUT FF 34
    全体 LUT 1475 FF 2270
  直接assign:
    CLB LUTs 45 CLB Registers 45 CARRAY8 8 CLB 8 LUT as Logic 45 LUT FF 30

--------
2048ワードのリングバッファ
reg [23:0] data[0:2047];
reg [7:0] ctrl[0:2047];
reg [11:0] cwoffset, roffset, dwoffset, ndummy;
cwoffsetは0から開始で毎クロックインクリメント、roffsetは8くらいから開始で
毎クロックインクリメント。差は常に変わらない。
dwoffsetは!DEならcwoffsetと同一の値、DE && VALIDならインクリメント、
DE && !VALIDならインクリメントしない。
DE && !VALIDならndummyをインクリメント。
!DEならndummyを0に。
if (!RESETN) begin
  cwoffset <= 0;
  dwoffset <= 0;
  roffset <= 8;
end else begin
  cwoffset <= cwoffset + 1;
  roffset <= roffset + 1;
  if (!I_DE) begin
    dwoffset <= cwoffset + 1;
  end else if (I_VALID) begin
    dwoffset <= dwoffset + 1;
  end
  ctrl[cwoffset] <= I_CTRL;
  data[dwoffset] <= I_DATA;
  o_ctrl <= ctrl[roffset];
  o_data <= data[roffset];
end

--------
xが奇数のピクセルのみ出力(VALID==1)する。
O_Y0 = y_7; 偶数ピクセルののY値
O_Y1 = yuv[6][23:16]; 奇数ピクセルのY値。Y0の右ピクセル。
O_UV = uv_6;
uv_6はxが偶数ピクセルのときにセットされ、奇数のときは変化しないので
出力されるのは0のときのU, 2のときのV値。
Y0: x==0,2のY値
Y1: x==1,3のY値
UV: x==0のU値、x==2のV値

--------
シェーダ
pcx4_iはピクセルのxを4で割った余り。0, 1, 2, 3のいずれか。
pcx4_iが0のとき、U値はその位置のピクセルを引けばよい 現pairのUV値を引く
                 V値は-2と+2の平均 左pairのUV値と右pairのUV値を引く
pcx4_iが1のとき、U値は-1と+3を3:1 現pairのUV値と右右pairのUV値を引く
                 V値は-3と+1を1:3 左pairのUV値と右pairのU値を引く
pxc4_iが2のとき、U値は-2と+2の平均 左pairのUV値と右pairのUV値を引く
                 V値はその位置のピクセルを引けばよい 現pairのUV値を引く
pxc4_iが3のとき、U値は-3と+1を1:3 左pairのUV値、右pairのUV値を引く
                 V値は-1と+3を3:1 現pairのUV値と右右pairのUV値を引く

--------
RGBへ戻す
1, 0, 1.13983
1, -0.39465, -0.58060
1, 2.03211, 0

--------
pi pico
GP16 = SPI0 RX
#GP17 = SPI0 CSn
GP18 = SPI0 SCK
#GP19 = SPI0 TX

CK_IO11 SCLK #4 - GP18
CK_IO12 RX - GPI16

--------
QT py
D8 SCK - CK_IO11
D9 MISO - CK_IO12

-------
yuv full swing

[0..255]と[-128..127]に収まる
Y = +77r +150g +29b
Cb = -43r -84g +128b
Cr = +127r -106g -21b
CbとCrは128加えて[0..255]に収める

GLSLで逆変換
CbとCrに(128/255)を減じ、次でRGBに変換
[[ 9.96074463e-01  4.93749408e-03  1.40562660e+00]
 [ 9.97438770e-01 -3.44325245e-01 -7.21328904e-01]
 [ 9.89187958e-01  1.76788275e+00 -1.16940649e-03]]

77;150;29;43;84;128;127;106;21
77 1001101
150 10010110
29 11101
43 101011
84 1010100
128 10000000
127 1111111
106 1101010
21 10101

-------
5/4 名前変更
PEEK_DMA_ADDR (verilogソースも変更9
HDMI_IN_GPIO
HDMI_IN_STAT

-------
電力
vcnet_1g: 待機2W, 使用3W
PC4台 静止30W
vcnet_10g: 待機12W, 使用12W
dell: 待機0W, 静止47W, 最大165W
habuild: 待機1W, 静止24W, 最大100W
ha77: 待機0W, 静止40W, 最大330W
ha117: 待機0W, 静止90W, 最大500W

------------------------------------------
aesku040
mt25qu256-spi-x1_x2_x4

------------------------------------------
nmcli connection modify (interface-name) 802-3-ethernet.mtu 9000

/etc/sysctl.conf
net.core.rmem_max = 33554432
net.core.wmem_max = 33554432

------------------------------------------
windows client, switch1, 60i
vcnet_send_data sendvideo_time=4605 15561 300
vcnet_send_data sendvideo_time=4605 19660 300
vcnet_send_data sendvideo_time=4697 18249 300
vcnet_send_data sendvideo_time=4717 25531 300
vcnet_send_data sendvideo_time=4656 17327 300
vcnet_send_data sendvideo_time=4607 19677 300
vcnet_send_data sendvideo_time=4603 18750 300

linux client, switch1, 60i
[  2] 20.0-25.0 sec  27.5 KBytes  45.0 Kbits/sec
vcnet_send_data sendvideo_time=4927 153420 300
[  2] 25.0-30.0 sec  27.5 KBytes  45.0 Kbits/sec
vcnet_send_data sendvideo_time=4932 153424 300
[  2] 30.0-35.0 sec  27.5 KBytes  45.0 Kbits/sec
vcnet_send_data sendvideo_time=4906 153438 300
[  2] 35.0-40.0 sec  27.5 KBytes  45.0 Kbits/sec
vcnet_send_data sendvideo_time=4912 153356 300
[  2] 40.0-45.0 sec  27.5 KBytes  45.0 Kbits/sec
vcnet_send_data sendvideo_time=4899 153390 300
[  2] 45.0-50.0 sec  27.5 KBytes  45.0 Kbits/sec
vcnet_send_data sendvideo_time=4917 153392 300
[  2] 50.0-55.0 sec  27.5 KBytes  45.0 Kbits/sec

---------------------------------------
125000000bytes/sec
125000bytes/msec
125bytes/usec

xtime_l.h
COUNTS_PER_SECOND がCPUクロック周波数の半分

n byte送信するごとに n/125M sec = n/125M*COUNTS_PER_SECONDS count
n * COUNTS_PER_SECONDS / 125000000 count
KCNT = (1024 * COUNTS_PER_SECONDS / 125000000)
n byte送信するごとにtimerを n * KCNT / 1024 カウント待てばよい

------------------------------------------
vcnet_1gで#0000ffが色化けする

RGB 00 00 fe
YUV 1D FF 6B
Y0Y1UV 1D 1D FF/6B

RGB 00 00 ff
YUV 1d 00 6b
Y0Y1UV 1d 1d 00/6b
Uがおかしい。

u <= (u_16 + 128 + 32768) >> 8;
u_16 = 0x7f80;
0x7f80 + 0x80 + 0x8000 ちょうどあふれる


------------------------------------------
bit-banging
digitalWrite2回を1000回ループ
sparkfun pro micro 21100 us


------------------------------------------
UARTとdigital 0, digital 1 が共通

Uno, Nano, Mini, Mega, Due は共通なのでdigital 0と1を使えない
Leonardo, Micro, Zero は別なのでdigital 0と1は使える？

------------------------------------------
AVR bit-banging 並列

port B: digital 8 to 13
port C: analog input pings
port D: digital 0 to 7

DDRD: port D data direction register (r/w)
PORTD: port D data register (r/w)

#define DDRD      _SFR_IO8(0x11)
#define _SFR_IO8(io_addr) ((io_addr) + __SFR_OFFSET)

#define _BV(bit) (1 << (bit))

信号6本 LAST, CLK, DATA[3:0] 全部pullup CLKの正エッジでサンプリングする
read側動作:
1. LASTが1になるまで待つ
2. LASTが0になるまで待つ
3. CLKが1になるまで待つ
4. DATA[3:0]とLASTを読む。LASTが1なら最後のデータなので終了
6. CLKが0になるまで待つ
7. 3.へ戻る

write側動作:
0. トランザクション開始前は全部の信号を1にする
1. DATA[3:0]をセット、LASTに最後のデータかどうかをセットし、CLKを0にする
2. 少し待つ
3. CLKを1にする
4. 少し待つ
5. 終了でないなら2.へ戻る

------------------------------------------
Uno R4 micros()がさかのぼる

unsigned long micros() {
        // Convert time to us
        NVIC_DisableIRQ(main_timer.get_cfg()->cycle_end_irq);
        uint32_t time_us = ((main_timer.get_period_raw() - main_timer.get_counter()) * 1000 / main_timer.get_period_raw()) +  (agt_time_ms * 1000);
        NVIC_EnableIRQ(main_timer.get_cfg()->cycle_end_irq);
        return time_us;
}
((period - couter) * 1000 / period) + (agt_time_ms * 1000)

パッチ作成済

------------------------------------------
Uno R4

extern "C" const PinMuxCfg_t g_pin_cfg[] = {
  { BSP_IO_PORT_03_PIN_01,    P301   }, /* (0) D0  -------------------------  DIGITAL  */
  { BSP_IO_PORT_03_PIN_02,    P302   }, /* (1) D1  */
  { BSP_IO_PORT_01_PIN_05,    P105   }, /* (2) D2  */
  { BSP_IO_PORT_01_PIN_04,    P104   }, /* (3) D3~ */
  { BSP_IO_PORT_01_PIN_03,    P103   }, /* (4) D4  */
  { BSP_IO_PORT_01_PIN_02,    P102   }, /* (5) D5~ */
  { BSP_IO_PORT_01_PIN_06,    P106   }, /* (6) D6~ */
  { BSP_IO_PORT_01_PIN_07,    P107   }, /* (7) D7  */
  { BSP_IO_PORT_03_PIN_04,    P304   }, /* (8) D8  */
  { BSP_IO_PORT_03_PIN_03,    P303   }, /* (9) D9~  */
  { BSP_IO_PORT_01_PIN_12,    P112   }, /* (10) D10~ */
  { BSP_IO_PORT_01_PIN_09,    P109   }, /* (11) D11~ */
  { BSP_IO_PORT_01_PIN_10,    P110   }, /* (12) D12 */
  { BSP_IO_PORT_01_PIN_11,    P111   }, /* (13) D13 */
  { BSP_IO_PORT_00_PIN_14,    P014   }, /* (14) A0  --------------------------  ANALOG  */
  { BSP_IO_PORT_00_PIN_00,    P000   }, /* (15) A1  */
  { BSP_IO_PORT_00_PIN_01,    P001   }, /* (16) A2  */
  { BSP_IO_PORT_00_PIN_02,    P002   }, /* (17) A3  */
  { BSP_IO_PORT_01_PIN_01,    P101   }, /* (18) A4/SDA  */
  { BSP_IO_PORT_01_PIN_00,    P100   }, /* (19) A5/SCL  */

  { BSP_IO_PORT_05_PIN_00,    P500   }, /* (20) Analog voltage measure pin  */
};

Port1を使うか。D2からD7の6本が使える。
Port1, [7:2]を使う。bit順に注意。

8bit版bitbanging(sketch_renesas_bitbanging)はSPIと重なるので不可。

------------------------------------------

glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width,
  GLsizei height, GLint border, GLenum format, GLenum type, const void *data);

target
    書込先テクスチャの種類。その種類をtargetとしてbindされているテクスチャへ
    データが書き込まれる。GL_TEXTURE_2Dなど。
level
    書込先テクスチャのどのmipmapレベルへ書き込むかを指定する。
internalformat
    書込先テクスチャの形式を指定する。GL_RGBAのようなbase internal formatか、
    GL_RGBA8のようなsized internal formatなどを指定できる。
width
    テクスチャの幅
height
    テクスチャの高さ
border
    これは0にしなければならない
format
    Specifies the format of the pixel data.
    'format' determines the composition of each element in 'data'.
    おそらくpixel dataとは引数'data'のこと。elementとはおそらく個々のピクセル、
    compositionとは個々のピクセルのデータを構成するR, G, Bなどの成分(おそらく
    componentと呼んでいるもの)の組み合わせと並び順のこと。
type
    Specifies the data type of the pixel data.
    おそらくpixel dataとは引数'data'のこと。
    (https://www.khronos.org/opengl/wiki/Pixel_Transfer)
    format G_RGBAでtypeがGL_UNSIGNED_BYTEなら各pixelは4byteからなることを表す。
    typeとしてGL_UNSIGNED_SHORT_5_6_5のようなもの(packed type)をtypeに指定
    すると、1ピクセルがGL_UNSIGNED_SHORTでRGBがそれぞれ5, 6, 5bitからなる
    ことを表す(endiannessは?)。
data
    Specifies a pointer to the image data in memory.
    おそらくimage dataとpixel dataとは同じもの。
    一個のピクセルのデータを'format'と'type'で指定した形式のバイト列を、
    widthだけ繰り返し、さらにそれをheightだけ繰り返した形式のメモリ領域
    の先頭アドレスを'data'に指定する(ものと思われる)。

------------------------------------------
YUY2

Y, U, Y, V のバイト順。
UとVは2ピクセルのうち左側のピクセルの値が書かれている。右側のピクセルの
値は補間する。

------------------------------------------
NV12

Y値を1920*1080バイト、
その次にUV値を交互に1920*540バイト。
UV値を引く処理:
uvx = floor(pc.x * 0.5)
uvy = floor(pc.y * 0.5)  あとでvideo_sizeを加える
左上ピクセル: (uvx,uvy), (uvx,uvy-1) を引き平均する
左下ピクセル: (uvx,uvy), (uvx,uvy+1) を引き平均する
右上ピクセル: (uvx,uvy), (uvx,uvy-1), (uvx+1,uvy), (uvx+1,uvy-1)
右下ピクセル: (uvx,uvy), (uvx,uvy+1), (uvx+1,uvy), (uvx+1,uvy+1)

------------------------------------------
バッファロー3入力

#1
(spresense)
9002,4547,550,579,519,611,518,611,519,579,550,579,550,580,518,611,519,579,550,1709,549,1709,519,1709,549,1709,519,1709,549,1709,519,1709,549,1709,519,610,519,610,519,1709,549,580,519,610,519,580,549,580,549,580,519,1739,519,1709,549,580,519,1709,549,1709,549,1709,519,1709,549,1709,519,40405,9002,2289,549

9033,4516,550,549,580,549,549,580,549,580,550,549,580,549,549,580,549,580,550,1678,580,1678,550,1678,580,1678,550,1708,550,1678,550,1708,550,1709,549,580,519,579,550,1709,549,580,519,610,519,580,549,580,549,580,549,1709,519,1709,549,580,519,1709,549,1709,519,1739,519,1709,549,1709,519,40405,9002,2258,580

(due)
9012,4511,566,581,539,582,537,583,542,583,537,582,537,583,544,581,539,586,539,1707,537,1680,564,1702,544,1679,565,1680,565,1702,542,1703,538,1712,538,582,538,583,537,1707,537,583,542,583,538,582,538,581,544,587,538,1702,543,1702,542,583,539,1706,538,1706,538,1703,537,1707,537,1708,539,40408,9006,2256,560

9012,4539,543,583,537,582,537,583,542,583,538,581,539,586,539,581,538,588,537,1707,537,1708,538,1706,538,1702,543,1702,542,1702,538,1706,539,1712,538,583,537,582,537,1708,538,582,543,582,538,581,539,581,539,588,542,1702,537,1708,538,581,544,1701,539,1707,537,1707,537,1708,539,1706,538,40399,9006,2279,542



#2
(spresense)
9002,4517,549,580,549,580,549,550,579,550,549,580,549,580,549,580,549,580,519,1709,549,1709,519,1739,519,1709,550,1708,519,1709,550,1708,519,1740,519,579,550,579,519,611,518,1709,550,579,519,611,518,611,519,579,550,1709,549,1709,519,1709,549,580,519,1708,550,1709,519,1708,550,1709,549,40405,9002,2289,519

(due)
9007,4540,537,560,565,578,543,582,537,583,538,587,538,581,538,582,543,561,565,1701,543,1702,538,1707,538,1708,537,1708,537,1708,538,1706,538,1706,539,583,537,588,537,582,537,1708,539,581,538,587,538,581,539,588,537,1708,537,1707,539,1700,544,581,539,1703,542,1702,543,1702,538,1711,539,40403,9006,2279,542

9008,4513,565,582,538,581,544,581,539,582,537,583,542,583,537,582,543,583,538,1684,560,1706,539,1680,565,1679,567,1679,566,1678,566,1680,565,1707,537,583,539,587,538,581,539,1707,537,583,537,588,537,582,537,588,538,1707,538,1708,537,1708,537,582,537,1708,538,1707,538,1707,537,1708,537,40406,9008,2255,561


#3
(spresense)
9002,4517,579,550,549,580,549,580,549,550,579,550,549,580,549,580,549,580,549,1679,549,1709,549,1679,580,1678,549,1679,580,1678,549,1679,580,1678,549,611,519,1708,550,580,549,1678,550,579,550,580,549,580,519,610,519,1709,549,580,549,1709,519,580,549,1709,549,1709,519,1709,549,1709,519,40435,9002,2259,549

(due)
9011,4539,538,581,544,581,539,582,537,584,542,583,537,582,543,582,538,587,538,1707,538,1707,537,1703,543,1702,543,1702,543,1702,543,1702,543,1707,538,582,538,1707,538,588,537,1707,537,583,537,583,538,587,538,587,538,1708,537,583,537,1707,537,583,544,1700,544,1703,537,1708,537,1707,538,40436,8985,2277,544

9012,4517,560,584,537,582,543,582,537,583,538,587,538,581,538,582,543,587,538,1703,537,1708,538,1706,539,1706,538,1707,537,1709,537,1707,538,1707,538,583,542,1702,543,583,537,1707,538,582,538,581,539,588,537,588,537,1708,537,583,538,1706,538,582,538,1708,537,1707,537,1708,538,1707,538,40409,9007,2256,565


出所不明5入力

#1
9338,4578,549,610,550,610,549,611,549,610,550,579,580,611,549,580,579,1709,550,1709,549,1739,550,1709,549,1740,549,1709,549,1709,580,1709,549,610,550,1739,550,610,549,1709,549,611,549,610,550,610,549,611,549,610,550,610,549,1709,580,610,550,1709,549,1709,580,1709,549,1709,549,1740,549,40130,9430,2288,550


------------------------------------------
ラズパイ等電源外付け

リモートからpoweronを押下すると電源がonになる
リモートからpoweronを長押しすると電源がoffになる
ラズパイからpoweroffを押下すると電源がoffになる
リモートからの制御は3.5ミニジャックで


------------------------------------------
flip動作


ネット送信した行が画面下端に達すると行を画面上端に戻し、waiting_flipを1にする。

DMA転送フレームがcur_video_frameと一致しアドレスが32行以降のとき、
  cur_disp_frame = cur_video_frame;
  (次のパススルー表示フレームを現DMA転送フレームの値にセット)
  if (waiting_flip) { cur_read_frame = cur_video_frame; waiting_flip = 0; }
  (ネット送信が画面上端待機中ならネット送信フレームを現DMA転送フレームの値
  にセットしwaiting_flipを0にする)
  cur_video_frameを、cur_read_frameともcur_disp_frameとも異なる値にセット。
  cur_video_frameとcur_disp_frameをレジスタに反映させる。


cur_video_frame: 次のdma転送フレームとして指定しているフレーム
dma frame: DMA転送中フレーム
cur_read_frame: ネット送信フレーム

問題: dma転送からネット送信までのバッファリング猶予が短く、フレームが飛ばされる

変更後の方針
1. cur_video_frameは4フレームのバッファを順に回す
2. cur_disp_frameはcur_video_frameの一つ後ろを指定
3. cur_read_frameはネット送信に合わせて進めるがdma転送位置を追い越さないように
4. waiting_flip廃止



