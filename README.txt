
----------------------------------------------------------------------
vcnetについて

KVM over IP サーバとクライアントです。ネットワーク越しにPC等を操作でき
ます。サーバはFPGAとマイコンで構成され、HDMI信号のキャプチャとUSBキー
ボード操作、HDMI切替器の制御をおこないます。クライアントソフトウェアは
Windows等で動作します。LAN内で使うことを想定しているため、通信路は暗号
化していません。

もともと手持ちのFPGA開発ボードで作ったものなのであまり役立たないかもし
れませんが、現状のままでソースを公開します。ドキュメントも不十分ですが
ソースコードを参照してください。

このリポジトリにはDigilent社、Xilinx社などが権利を持つコードも部分的に
含まれているため、それらの著作権の扱いについては個々のファイルを参照し
てください。それ以外の部分についてはCOPYRIGHT.txtを参照してください。

----------------------------------------------------------------------
対応するハードウェア

このリポジトリは以下のハードウェアに対応するソースが含まれています。
  FPGA開発ボード
    - Digilent ArtyZ7-10, ArtyZ7-20 のいずれか。これらのボードのHDMI
      IN端子と1000BASE-T Ethernetを使います。帯域上限が1Gbpsのため、
      1920x1080 50i YUV422での伝送が可能です。HDMIのオーディオには対
      応していません。
    - Avnet AES-KU040-DB-G + Digilent FMC-HDMI メザニンカード。FMCカー
      ドのHDMI 1端子(ADV7611使用)とボードのSFP+ケージを使います。
      1920x1080 60p RGB24bit非圧縮の伝送が可能です。HDMIのオーディオに
      も対応します。
  マイコンモジュール
    - SparkFun Pro Microまたは互換モジュール。3.3v版のものであればFPGA
      ボードと直接接続できます。5v版でも動くはずですが、FPGAボードとの
      間でIO電圧変換が必要です。
    - Raspberry Pi Pico。これはIO電圧が3.3vなのでFPGAボードと直接接続
      できます。
  HDMI切替器
    - メーカー不明の5ポートHDMI切替器。ネット上のバッタ屋で1000円程度
      で売っています。3.5mmミニプラグのリモコン受信センサーがついてい
      ればおそらく同一の品だと思われます。FPGAから操作してHDMI入力ポー
      トを切り替えることができます。
  USBオーディオモジュール
    - USBオーディオデバイスとして動作し、オーディオ出力をI2S信号として
      取得できるようなもの。
    - Raspberry Pi Pico のサンプルの、
      pico-playground/apps/usb_sound_card
      をビルドして書き込むと、USBオーディオ出力をI2S信号として取得でき
      ます。

----------------------------------------------------------------------
ハードウェア構成と結線

    FPGAとマイコンモジュールはSPIで通信します。マイコン側がmasterにな
    ります。CS信号は使いません。最大5個までのマイコンを接続できます。
    マイコンとFPGAはGND, SCLK, MISOの3本を結線します。各信号線はプル
    ダウンします(2kΩで問題なく動作しています)。

    ArtyZ7     マイコン
    -------------------
    GND        GND
    CK_IO0     SCLK #0
    CK_IO1     MISO #0
    CK_IO5     SCLK #1
    CK_IO6     MISO #1
    CK_IO7     SCLK #2
    CK_IO8     MISO #2
    CK_IO9     SCLK #3
    CK_IO10    MISO #3
    CK_IO11    SCLK #4
    CK_IO12    MISO #4

    AES-KU040  マイコン
    -------------------
    GND        GND
    PMOD2_2    MISO #0
    PMOD2_3    SCLK #0
    PMOD1_0    MISO #1
    PMOD1_1    SCLK #1
    PMOD1_2    MISO #2
    PMOD1_3    SCLK #2
    PMOD1_4    MISO #3
    PMOD1_5    SCLK #3
    PMOD1_6    MISO #4
    PMOD1_7    SCLK #4

    HDMI切替器をFPGAから制御する場合には、切替器の赤外線センサーのかわ
    りに制御用の信号線を結線します。Left(ミニプラグの先端)には約4.5Vが
    供給されいて、Right(ミニプラグの中央)はプルアップされています。信
    号線はレベルシフタで4.5Vに昇圧します(直結でも一応動作はします)。

    ArtyZ7     3.5mmミニプラグ
    --------------------
    GND        GND(根元)
    CK_IO13    Right(中央)
    
    AES-KU040  3.5mmミニプラグ
    --------------------
    GND        GND(根元)
    PMOD2_1    Right(中央)

    オーディオ出力をキャプチャする場合には、I2S信号をFPGAに渡すように
    結線します。各信号線はプルダウンします。

    ArtyZ7     I2S
    --------------------
    GND        GND
    CK_IO2     LR
    CK_IO3     DAT
    CK_IO4     BCLK

----------------------------------------------------------------------
ディレクトリ構成

  vcnet_artyz7_10_hw
  vcnet_artyz7_20_hw
    それぞれのFPGA開発ボード用の論理回路ソース。Vivadoで開きます。
  vcnet_artyz7_10_sw
  vcnet_artyz7_20_sw
    それぞれのFPGA開発ボード用のソフトウェアのソース。Vitisで開きます。
  vcnet_10g
    AESKU040用論理回路ソース。Vivadoで開きます。
  axis_rgb2yuv422
    RGBからYUVへ変換する回路を高位合成するためのソース。Vitis HLSで開
    きます。ArtyZ7版で使用しています。
  sketch_vcnet_usb
    マイコンに書き込むソフトウェアのソース。Arduino IDEで開きます。
  arduino_libraries
    マイコンに書き込むソフトウェアのソース(C++ライブラリ)。
  vcnet_client
    クライアントのソース。

----------------------------------------------------------------------
ビルド手順

sketch_vcnet_usb
  1. Arduino IDE に以下のライブラリをインストールする。
     https://github.com/MHeironimus/ArduinoJoystickLibrary
  2. vcnet/arduino_libraries/usb_mod ディレクトリを Arduino IDE のライ
     ブラリディレクトリ(WindowsならDocuments/Arduino/libraries)の下に
     コピーする。
  3. Arduino IDE でvcnet/sketch_vcnet_usb/sketch_vcnet_usb.ino を開く。
     書き込み対象のボードを選択(Raspberry Pi PicoのときはArduino Mbed
     OS RP2040 Boards -> Raspberry Pi Pico を選択、SparkFun Pro Micro
     のときは SparkFun AVR Boards -> SparkFun Pro Micro を選択)し、ビ
     ルドしてマイコンに書き込む。

vcnet_10g
  1. vivado 2018.2 で vcnet_10g/vcnet_10g.xpr を開く
  2. Flow Navigator -> IP INTEGRATOR -> Open Block Design
  3. Flow Navigator -> PROGRAM AND DEBUG -> Generate Bitstream
  4. Flow Navigator -> PROGRAM AND DEBUG -> Open Hardware Manager
     でFPGAやQSPIフラッシュメモリに書き込む
  5. QSPIフラッシュメモリに書き込んだ状態で電源を入れるとvcnetサーバが
     動作する。IPアドレスはブロックデザインにハードコードされていて、
     アドレス192.168.200.3のポート9999で待ち受ける。
 
axis_rgb2yuv422
  1. vitis hls 2021.2 で Open Project 選択、axis_rgb2yuv422 フォルダを
     選択
  2. Project -> New Solution 選択、Part Selection に xc7z010clg400-1
     を選択、Finish 押下
  3. Solution -> Run C Synthesis -> Active Solution 選択、OK 押下
  4. Solution -> Export RTL 選択、OK 押下

vcnet_artyz7_10_hw
  1. あらかじめ axis_rgb2yuv422 をビルドしておく。
  2. vivado 2021.2 で vcnet_artyz7_10_hw/vcnet_artyz7_10_hw.xpr を開く
  3. Flow Navigator -> IP INTEGRATOR -> Open Block Design
  4. Flow Navigator -> PROGRAM AND DEBUG -> Generate Bitstream
  5. File -> Export -> Export Hardware
     OutputとしてInclude bitstreamをチェックして
     bd_vcnet_1g_wrapper.xsaを書き出す

vcnet_artyz7_10_sw
  1. あらかじめ vcnet_artyz7_10_hw をビルドして xsa を書き出しておく。
  2. vitis 2021.2 で workspaceとしてvcnet_artyz7_10_sw を指定して
     Launch を押下
  3. Welcome ページが開くので Project -> Import Project
     Import Type は Eclipse workspace or zip file をチェックしてNext
     を押下
     Select root directory に vcnet_artyz7_10_sw を指定
     Options の Copy projects into workspace のチェックを外す
     Projects: の Select All を押下すると vcnet と vcnet_system が選択
     される。
     Finish を押下
  4. File -> New -> Platform Project を選択
     Platform project name: に bd_vcnet_1g を指定して Next
     Create a new platform from hardware (XSA) の Browse をクリック、
     vcnet_artyz7_10_hw/bd_vcnet_1g_wrapper.xsa を指定し、Finish
  5. Explorer -> platform.spr をダブルクリック
     bd_vcnet_1g -> ps7_cortexa9_0 -> starndalone on ps7_cortexa9_0
     -> Board Support Package をクリック
     Load BSP setting from file をクリック
     vcnet/misc/system.mss を開く
     Reset BSP Sources をクリック
  6. Assistant -> bd_vcnet_1g を右クリック、Build 選択
     Assistant -> vcnet_system -> vcnet -> Release を右クリック、
     Build 選択
  7. Xilinx -> Create Boot Image -> Zynq and Zynq Ultrascale 選択
     Output BIF file path: Browseを押下、output.bif を指定して 保存
     を押下
     Boot image partitions に以下のものを追加
       bd_vcnet_1g/zynq_fsbl/fsbl.elf
       bd_vcnet_1g/hw/bd_vcnet_1g_wrapper.bit
       vcnet/Release/vcnet.elf
     Create Image を押下
  8. 出来上がった BOOT.bin ファイルをFATフォーマットしたSDカードに書き
     込む。また以下のような内容(行頭に空白は入れない)のファイルを
     vcnet.cnf という名前でSDカードに書き込む。
       ip=192.168.100.250
       mac=02:00:00:00:64:fa
  9. FPGAボードをSDカードから起動するように設定し、電源を入れるとvcnet
     サーバが動作する。

vcnet_client
  1. Windows, Linux, MacOS などに以下のライブラリを用意する。
     - SDL2
       https://wiki.libsdl.org/SDL2/FrontPage
     - SDL_ttf
       https://wiki.libsdl.org/SDL_ttf/FrontPage
     - glew (Windowsのみ必要)
       https://github.com/nigels-com/glew
  2. TTFフォントを用意する。Windowsではvcnetクライアントの実行形式と同
     じディレクトリの mplus-1m-bold.ttf を読み込むようになっている。
     vcnet.cpp を参照。
  3. vcnet.cpp をコンパイルする。Linux や Mac OS では Makefile が使える
     ので make を実行する。Windows でのビルド方法は build_windows.sh
     の中身を参照。Visual Studio 2019 でビルドする場合は
     vcnet_client.sln を使うことができる。

----------------------------------------------------------------------
クライアントの設定

vcnetクライアントの設定ファイル(既定ではvcnet.confという名前)には、
key:value の形で設定を指定する。vcnet_client/example 以下に設定ファイ
ルの例がある。以下のような設定項目が利用できる。

device0
  (例) device0: ip=192.168.1.10,port=5001,socktype=tcp,spi=0
  接続先デバイスの設定を、key=value の形をカンマ区切りで連結したもの
  で指定する。以下のような項目がある。
  socktype
    vcnetサーバのソケットの種類を指定する。vcnet_10gのときはudpを、そ
    うでないときはtcpを指定する。
  ip
    (例) ip=192.168.1.5
    vcnetサーバのipアドレスを指定する。vcnet_10gのときは192.168.200.3
    を指定する。
  port
    vcnetサーバのポートを指定する。vcnet_10gのときは9999、それ以外の
    ときはサーバ側で変更していないなら5001。
  spi=0
    マイコンへのSPI接続の番号(0から4まで)を指定する。
  wol
    (例) wol=00:11:22:33:44:55
    デバイスへの接続時(クライアント起動時)にWake on Lanマジックパケッ
    トを送信する。対象PCをスリープ状態から復帰させるのに使う。
  ir
    (例) ir=9072:4416:633:497:628:497:627:497:627:...
    デバイスへの接続時にHDMI切替器へ送信する信号を指定する。各ポートへ
    切り替えるための値については下の "HDMI切替器への信号" を参照。
  absmouse
    1を指定すると、絶対値モードのUSBマウスで対象デバイスを操作するよう
    になる。現在のところ対象デバイスでWindowsが動いている場合にのみ実
    用的。既定値である0のときは相対値モードで動作する。相対値モードの
    ときは、vcnetクライアントのウインドウにフォーカスが当たるとマウス
    操作はvcnetに捕捉され、右Alt又はマウスボタン5などでフォーカスを解
    除するまでマウス操作が対象デバイスへ送られる。一方、絶対値モード
    のときは、フォーカスにかかわらずvcnetウインドウの上でマウス操作を
    すると対象デバイスへマウス操作が反映されるようになる。
  absmousebutton=0
    1を指定すると、対象デバイスでの絶対値モードマウスのマウスボタンで
    操作するようになる。absmouseの設定値に合わせる必要はなく、通常は0
    のままでよい。
  wheel_dir=0
    1を指定するとマウスホイールの動作の向きが反転する。

use_gl:
  (例) use_gl: 1
  1のときvcnetクライアントがOpenGLを使って描画する。既定値は1。

vsync
  1にするとvcnetクライアントが1フレーム表示ごとに垂直同期を待つように
  なる。テアリングが起きなくなるが、遅延は少し大きくなる。また現在の
  実装では、リモートの垂直同期周波数がローカルと同一程度以上のときに
  大幅に画面更新が遅延する。

logmask
  vcnetクライアントどのような種類のログを出力するかどうかを指定する。

keymodmap
  (例) keymodmap: 2:3,3:2
  キーボードのmodifierを入れ替えるマップを指定する。ローカル側とリ
  モート側のmodifier番号をコロンで区切り、それをカンマ区切りで複数
  指定できる。上の例は左Altと左Guiを入れ替える。modifier番号は以下
  の通り。
    0 左Ctrl
    1 左Shift
    2 左Alt
    3 左Gui(windowsロゴキー)
    4 右Ctrl
    5 右Shift
    6 右Alt
    7 右Gui

keymap
  (例) keymap: 21f:234,64:31
  (例) keymap: 35:10039
  キーボードのキーを入れ替えるマップを指定する。ローカル側とリモート
  側のkey番号をコロンで区切り、それをカンマ区切りで複数指定できる。
  key番号は、0から7bitがUSB HID Keyboard(Page 07)のUsage ID、8から
  15bitがmodifierのビットマスク、16bit(リモート側のみ指定可能)には
  key upイベントを追加発生させるかどうかのフラグ、を指定する。上の
  例は、21f:234 が「Keyboard 2 and @」キー(0x1f)と左Shiftを
  「Keyboard ' and "」キー(0x34)と左Shiftに、64:31 が「Keyboard
  Non-US \ and |」キー(0x64)を「Keyboard \ and |」にマップし、
  また 35:10039 が「Keyboard Grave Accent and Tilde」キー(0x35)を
  「Keyboard Caps Lock」キー(0x39)にマップし、key upイベントを追加
  発生させる。0x35キーはJISキーボードの半角/全角キーで、Windowsの
  日本語環境ではkey up時にイベントがアプリに送られてこないため、
  key upイベントを追加発生させないとキーが押しっぱなしになる。キー
  コードついては以下の文書の「Keyboard/Keypad Page (0x07)」を参照。
  https://www.usb.org/document-library/hid-usage-tables-13

ch2usb@00
...
ch2usb@70
  ローカルからリモートへの文字列貼り付けの際の、文字とUSBキーコードの
  対応を指定する。リモートのOSがvcnetのキーボード配列をどのように認識
  しているか(JISであるかUSであるか)によって設定内容が変わる。設定例は
  リポジトリ内の example/vcnet_jis_keyboard.conf ファイルなどを参照。

joymap
  (例) joymap: b1:b4,a0:h3:-32768:h1:32768,a5:b7:65536:n0:-32768
  USBゲームコントローラのボタンを入れ替えるマップを指定する。値はカンマ
  区切りで、各リモートのボタンやアナログ軸がローカル側の何を参照するか、
  を指定する。ボタン等は以下のような英数字で指定する。
    b0 から b15 まで: コントローラの各ボタン
    h0 から h3 まで: hat(十字キー)の上、右、下、左
    a0 から a5 まで: アナログ軸
    n0: 定数
  ボタンとhatについては1bitの値、アナログ軸については-32768から32767ま
  での整数値が計算される。計算式は、リモート側ボタン等を表す英数字の
  後ろにコロン区切りで、ローカル側のボタン等を表す英数字とパラメータ整
  数を交互に連結したもので表現する。
  (1) リモート側がボタンかhatのとき
     (1-1) ローカル側にボタンかhatを指定したとき、パラメータは無視され、
           ローカル側のボタンが現在押されていれば1、そうでなければ0
     (1-2) ローカル側にアナログ軸を指定したとき、軸の現在値の符号がパラ
           メータ符号と一致し、かつ現在値の絶対値がパラメータの絶対値
           以上なら1、そうでないなら0
     複数指定された場合はそれらすべての論理和がリモート側ボタン状態の
     値になる。
  (2) リモート側がアナログ軸のとき
     (1-1) ローカル側にボタンかhatを指定したとき、ローカル側ボタンが現
           在押されていればパラメータの値、そうでないなら0
     (1-2) ローカル側にアナログ軸を指定したとき、その軸の現在値
     (1-3) ローカル側に n0 を指定したとき、パラメータの値
     複数指定された場合はそれらすべての和がリモート側アナログ軸の値に
     なる。計算は符号付32bit値でおこなわれ、結果が-32768から32767の範
     囲に収まらない場合には丸められる。
  たとえば b1:b4 ならリモートボタン1はローカルボタン4の現在値が反映さ
  れ、a0:h3:-32768,h1:32768 ならリモートアナログ軸0番はローカルhat3
  (下)が押されていれば-32768、ローカルhat1(上)が押されていれば32768、
  いずれも押されていなければ0の値になる。アナログ軸の4と5は通常トリガ
  状になっていて、無操作時に-32768になることが期待されているが、たとえ
  ば a5:b7:65536:n0:-32768 のように指定すれば、リモートのアナログ軸5
  番はローカルのボタン7が押されていれば32768(=65536-32768)、押されてい
  なければ-32768の値を取るようにできる。

----------------------------------------------------------------------
HDMI切替器への信号

HDMI切替器への信号パターンは以下の通り。これをir=...に指定する。
おそらく全個体同じ信号パターンであると思われる。

#1
9072:4416:633:497:628:497:627:497:627:498:627:497:628:496:628:497:628:1593:634:1594:627:1594:627:1595:628:1593:634:1593:628:1594:627:1595:633:491:628:1599:628:496:628:1595:627:497:627:497:628:497:628:496:628:496:628:496:629:1594:627:497:627:1595:628:1593:634:1593:628:1594:627:1595:627:39498:9023:2167:633
#2
9078:4388:656:469:655:469:655:469:656:470:654:470:654:470:655:464:661:1566:655:1566:656:1567:654:1567:660:1562:661:1565:656:1566:655:1567:655:470:654:1567:656:1565:661:1561:661:464:660:465:659:465:660:464:661:463:661:464:655:469:661:463:661:1562:660:1561:661:1566:656:1538:683:1567:654:39460:9051:2139:661
#3
9100:4383:661:463:661:464:666:458:666:458:661:459:666:459:665:459:665:1562:661:1560:661:1561:666:1556:665:1557:666:1555:666:1561:666:1556:665:460:665:459:666:458:667:458:666:1555:666:458:666:460:665:459:665:459:665:1557:666:1555:666:1555:667:459:665:1556:665:1556:667:1560:667:1555:666:39449:9056:2134:665
#4
9034:4410:634:486:638:486:638:487:637:487:639:485:639:486:639:485:639:1588:633:1589:633:1589:633:1588:634:1587:639:1584:638:1583:638:1589:634:490:634:1560:661:492:633:491:633:1589:633:491:634:490:634:491:633:491:634:490:634:1589:638:1561:661:486:639:1582:639:1583:638:1589:633:1589:633:39481:9023:2167:628
#5
9061:4406:638:492:638:488:637:488:640:485:641:485:640:485:640:486:640:1585:638:1586:635:1588:635:1589:635:1585:638:1591:633:1591:635:1588:635:491:635:1585:638:1591:638:488:634:1589:640:1584:640:493:632:493:638:487:638:488:635:490:635:1589:640:485:640:486:640:1585:638:1586:640:1584:640:39474:9044:2163:635

----------------------------------------------------------------------
クライアントの操作

vcnetクライアントは引数に設定ファイルを指定することができる。指定しない
場合は vcnet.conf を指定した場合と同じ動作をする。Windowsで動くvcnet
クライアントでは、実行形式と同じ名前の文字列をキーとするmutexを使って
多重起動を防止しているため、同じパスに置いた実行形式は一度に一つのプロ
セスしか実行できない。

起動すると設定ファイルの device0 の項目の内容に従ってサーバに接続したり
Wake on Lan マジックパケットを送信したりする。サーバに接続するとHDMI
ポートの切り替えが実行される。

マウスが相対値モードのときは、ウインドウにフォーカスを当てるとマウス操
作が捕捉される。解除するには右Altかマウスボタン5を押すか、Alt + Tab
(ローカルがWindowsの場合)などでフォーカスを切り替える。

以下のような特殊なキー操作が利用できる。

右Alt
  マウスがvcnetクライアントに捕捉されているときに、捕捉を解除する。
  マウスボタン5でも同じ動作をする。

右Alt + RETURN
  フルスクリーン表示 on/off を切り替える。

右Alt + s
  画面右上に、画面周波数、解像度、オーディオ周波数などの情報を表示する。
  もう一度押すと消える。

右Alt + DEL
  リモートデバイスに Ctrl + Alt + Del を送る。

右Alt + i
  サーバ側でインタレース送信をするかどうかを切り替える。vcnet_artyz7
  サーバは既定で、キャプチャしたフレームをインタレース化してクライアン
  トに送信するが、このキー操作で無効にできる。ただしフレームレートが
  半分になる。vcnet_10g ではインタレース化しないため、このキー操作は
  無視される。

右Alt + v
  ローカルのクリップボードの内容を、キー操作を使ってリモートへペースト
  する。これを実行するためには ch2usb@00 の設定が必要。

